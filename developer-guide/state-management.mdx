---
title: "State Management"
description: "Managing application state across server and client"
---

## Overview

Lovertoon uses a hybrid state management approach optimized for React Server Components:

| State Type | Solution |
|------------|----------|
| Server State | TanStack Query (via tRPC) |
| Client State | React Context |
| Form State | React Hook Form |
| URL State | Next.js searchParams |

## Server State (tRPC + React Query)

### Query Pattern

```typescript
"use client";
import { api } from "~/trpc/react";

export function ComicList() {
  const { data, isLoading, error, refetch } = api.comic.getAll.useQuery({
    status: "active",
    limit: 20,
  });

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      {data?.map(comic => <ComicCard key={comic.id} comic={comic} />)}
    </div>
  );
}
```

### Query Options

```typescript
// Conditional fetching
const { data } = api.chapter.getById.useQuery(
  { id: chapterId },
  { enabled: !!chapterId } // Only fetch when chapterId exists
);

// Custom stale time
const { data } = api.category.getAll.useQuery(undefined, {
  staleTime: 5 * 60 * 1000, // Consider fresh for 5 minutes
});

// Refetch on window focus
const { data } = api.user.getCurrent.useQuery(undefined, {
  refetchOnWindowFocus: true,
});
```

### Mutation Pattern

```typescript
"use client";
import { api } from "~/trpc/react";

export function CreateComicButton() {
  const utils = api.useUtils();

  const createComic = api.comic.create.useMutation({
    onSuccess: () => {
      // Invalidate queries to refetch fresh data
      utils.comic.getAll.invalidate();
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  const handleCreate = () => {
    createComic.mutate({
      name: "New Comic",
      slug: "new-comic",
    });
  };

  return (
    <button
      onClick={handleCreate}
      disabled={createComic.isPending}
    >
      {createComic.isPending ? "Creating..." : "Create Comic"}
    </button>
  );
}
```

### Optimistic Updates

```typescript
const toggleFavorite = api.favorites.toggle.useMutation({
  onMutate: async ({ comicId }) => {
    // Cancel any outgoing queries
    await utils.favorites.isFavorite.cancel({ comicId });

    // Snapshot the previous value
    const previousValue = utils.favorites.isFavorite.getData({ comicId });

    // Optimistically update
    utils.favorites.isFavorite.setData({ comicId }, !previousValue);

    return { previousValue };
  },

  onError: (err, { comicId }, context) => {
    // Rollback on error
    utils.favorites.isFavorite.setData(
      { comicId },
      context?.previousValue
    );
  },

  onSettled: (_, __, { comicId }) => {
    // Refetch to ensure server state is correct
    utils.favorites.isFavorite.invalidate({ comicId });
  },
});
```

### Prefetching

```typescript
// Prefetch on hover
function ComicCard({ comic }) {
  const utils = api.useUtils();

  const handleMouseEnter = () => {
    utils.comic.getBySlug.prefetch({ slug: comic.slug });
  };

  return (
    <Link
      href={`/comics/${comic.slug}`}
      onMouseEnter={handleMouseEnter}
    >
      {comic.name}
    </Link>
  );
}
```

## Client State (React Context)

### Creating a Context

```typescript
// src/lib/contexts/AdultContentContext.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";

interface AdultContentContextType {
  showAdultContent: boolean;
  setShowAdultContent: (show: boolean) => void;
}

const AdultContentContext = createContext<AdultContentContextType | null>(null);

export function AdultContentProvider({ children }: { children: React.ReactNode }) {
  const [showAdultContent, setShowAdultContent] = useState(false);

  // Persist to localStorage
  useEffect(() => {
    const stored = localStorage.getItem("showAdultContent");
    if (stored) setShowAdultContent(JSON.parse(stored));
  }, []);

  useEffect(() => {
    localStorage.setItem("showAdultContent", JSON.stringify(showAdultContent));
  }, [showAdultContent]);

  return (
    <AdultContentContext.Provider value={{ showAdultContent, setShowAdultContent }}>
      {children}
    </AdultContentContext.Provider>
  );
}

export function useAdultContent() {
  const context = useContext(AdultContentContext);
  if (!context) {
    throw new Error("useAdultContent must be used within AdultContentProvider");
  }
  return context;
}
```

### Using Context

```typescript
"use client";
import { useAdultContent } from "~/lib/contexts/AdultContentContext";

export function AdultContentToggle() {
  const { showAdultContent, setShowAdultContent } = useAdultContent();

  return (
    <label className="flex items-center gap-2">
      <input
        type="checkbox"
        checked={showAdultContent}
        onChange={(e) => setShowAdultContent(e.target.checked)}
      />
      แสดงเนื้อหาสำหรับผู้ใหญ่
    </label>
  );
}
```

## Form State (React Hook Form)

### Basic Form

```typescript
"use client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { createComicSchema, type CreateComicInput } from "~/lib/schemas/comic";

export function ComicForm() {
  const form = useForm<CreateComicInput>({
    resolver: zodResolver(createComicSchema),
    defaultValues: {
      name: "",
      slug: "",
      status: "draft",
    },
  });

  const onSubmit = (data: CreateComicInput) => {
    console.log(data);
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div>
        <label>Name</label>
        <input {...form.register("name")} />
        {form.formState.errors.name && (
          <span>{form.formState.errors.name.message}</span>
        )}
      </div>

      <button type="submit" disabled={form.formState.isSubmitting}>
        Create
      </button>
    </form>
  );
}
```

### Form with tRPC Mutation

```typescript
"use client";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { api } from "~/trpc/react";

export function CreateComicForm() {
  const form = useForm<CreateComicInput>({
    resolver: zodResolver(createComicSchema),
  });

  const createComic = api.comic.create.useMutation({
    onSuccess: () => {
      form.reset();
      toast.success("สร้างการ์ตูนสำเร็จ");
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  const onSubmit = (data: CreateComicInput) => {
    createComic.mutate(data);
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
      <button
        type="submit"
        disabled={form.formState.isSubmitting || createComic.isPending}
      >
        {createComic.isPending ? "Creating..." : "Create"}
      </button>
    </form>
  );
}
```

### Form Arrays

```typescript
import { useFieldArray } from "react-hook-form";

export function ChapterImagesForm() {
  const { control, register } = useForm();

  const { fields, append, remove, move } = useFieldArray({
    control,
    name: "images",
  });

  return (
    <div>
      {fields.map((field, index) => (
        <div key={field.id} className="flex gap-2">
          <input {...register(`images.${index}.url`)} />
          <button type="button" onClick={() => remove(index)}>
            Remove
          </button>
        </div>
      ))}
      <button type="button" onClick={() => append({ url: "" })}>
        Add Image
      </button>
    </div>
  );
}
```

## URL State

### Search Params

```typescript
// src/app/(home)/comics/page.tsx
export default function ComicsPage({
  searchParams,
}: {
  searchParams: { category?: string; page?: string; sort?: string };
}) {
  const category = searchParams.category;
  const page = parseInt(searchParams.page ?? "1");
  const sort = searchParams.sort ?? "latest";

  return <ComicList category={category} page={page} sort={sort} />;
}
```

### Updating URL State

```typescript
"use client";
import { useRouter, useSearchParams, usePathname } from "next/navigation";

export function CategoryFilter() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const setCategory = (category: string | null) => {
    const params = new URLSearchParams(searchParams);

    if (category) {
      params.set("category", category);
    } else {
      params.delete("category");
    }

    // Reset to page 1 when changing category
    params.delete("page");

    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <select
      value={searchParams.get("category") ?? ""}
      onChange={(e) => setCategory(e.target.value || null)}
    >
      <option value="">All Categories</option>
      <option value="action">Action</option>
      <option value="romance">Romance</option>
    </select>
  );
}
```

### Shallow Routing

```typescript
// Update URL without navigation (preserves scroll position)
router.push(`${pathname}?${params.toString()}`, { scroll: false });
```

## Combining State Types

### Real-World Example

```typescript
"use client";

export function ComicBrowser() {
  // URL State - filters
  const searchParams = useSearchParams();
  const category = searchParams.get("category");
  const page = parseInt(searchParams.get("page") ?? "1");

  // Server State - data
  const { data, isLoading } = api.comic.getAll.useQuery({
    category,
    page,
    limit: 20,
  });

  // Client State - UI
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const { showAdultContent } = useAdultContent();

  // Derived state
  const filteredComics = useMemo(() => {
    if (!data) return [];
    return showAdultContent
      ? data
      : data.filter(c => !c.isAdult);
  }, [data, showAdultContent]);

  return (
    <div>
      <FilterBar category={category} />
      <ViewToggle mode={viewMode} onChange={setViewMode} />

      {isLoading ? (
        <LoadingSpinner />
      ) : viewMode === "grid" ? (
        <ComicGrid comics={filteredComics} />
      ) : (
        <ComicList comics={filteredComics} />
      )}

      <Pagination page={page} total={data?.totalPages ?? 1} />
    </div>
  );
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Prefer Server Components">
    Start with Server Components and add `"use client"` only when needed. This reduces client bundle size and improves performance.
  </Accordion>

  <Accordion title="Collocate State">
    Keep state as close to where it's used as possible. Don't lift state unless multiple components need it.
  </Accordion>

  <Accordion title="Use URL for Shareable State">
    Filters, pagination, and search queries should be in the URL so users can share links.
  </Accordion>

  <Accordion title="Invalidate After Mutations">
    Always invalidate relevant queries after mutations to keep UI in sync with server.
  </Accordion>

  <Accordion title="Handle Loading and Error States">
    Always provide feedback for loading and error states. Never leave users wondering what's happening.
  </Accordion>
</AccordionGroup>
